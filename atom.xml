<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Farewellswind</title>
  
  <subtitle>Daily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Farewellswind.github.io/"/>
  <updated>2018-11-24T14:26:07.842Z</updated>
  <id>http://Farewellswind.github.io/</id>
  
  <author>
    <name>Farewellswind</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://Farewellswind.github.io/2018/11/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://Farewellswind.github.io/2018/11/22/动态规划/</id>
    <published>2018-11-22T15:23:16.000Z</published>
    <updated>2018-11-24T14:26:07.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p><del>动规对于刚刚涉猎算法的我而言，简直是天书一般啊啊啊!</del><br>个人理解上，动态规划通常把问题划分成规模更小的子结构或者子状态。而当一个问题存在最优子结构时，动态规划就很可能是用得上的。<br>很大程度上，动规的原问题与子问题之间的差距仅仅是数据规模的不同，<del>这里可以类比到分治的思想(什么鬼例子)</del><br>其实就是一个树型啦！</p><h3 id="思考方向是从复杂到简单，而计算方向是从简单到复杂"><a href="#思考方向是从复杂到简单，而计算方向是从简单到复杂" class="headerlink" title="思考方向是从复杂到简单，而计算方向是从简单到复杂"></a><strong><em>思考方向是从复杂到简单，而计算方向是从简单到复杂</em></strong></h3><p>无后效性是一个问题可以用动态规划求解的标志之一，理解无后效性对求解动态规划类题目非常重要。<br>这便是某百科对于无后效性的解释。用实际例子来解释的话，可以联想上台阶的问题f(i)=f(i-1)+f(i-2),即你在每一级固定的台阶所作的选择，均不会受之前的选择的影响。而在2<em>n的地板上铺设瓷砖也是同样的道理。<br>在棋盘的问题下，假设有一个n</em>m的棋盘，要求将一枚棋子从左上角拿到右下角。这时便有两种可能。</p><ol><li>若题目中限定运动方向，如：仅可向下或者向右运动<br>那么这样其实总的步数我们是可知的为n+m，当棋子移动到(3,4)时，他要进行决策即向右或者向下走，棋子如何移动到点(3,4)对于目前的决策便没有影响。这便是体现了一种无后效性。</li><li>若题目中并无限定，可向四个方向运动(不能走重复的格子)<br>因为无法走重复的格子，所以可以把走过的格子进行标记。这样当再次搜索到的时候，决策数便减少了一种选择及之前的决策影响了未来的决策，这即是有后效性。</li></ol><div class="note info"><p>某阶段的状态一旦确定，则此后过程的演变不再受<strong>此前各种状态及决策的影响</strong></p></div>如此便可得到动态规划问题基础的解决模式：<div class="note primary"><p>(1) 确定问题的决策对象。<br>(2) 对决策过程划分阶段。<br>(3) 对各阶段确定状态变量<br>(4) 根据状态变量确定费用函数和目标函数。<br>(5) 建立各阶段状态变量的转移过程，确定状态转移方程。</p></div><p>由此我们可以得到动态规划问题一般的状态转移方程：<br>状态转移方程的一般形式：<br><div class="note success"><p>$f[U_k]=opt{f[U_k-1]+L[U_k-1,X_k-1]}$</p></div></p><p>其中,$U$表示状态状态;$X$表示策略;$L[U_k-1,X_k-1]$:状态$U_k-1$通过策略$X_k-1$到达状态$U_k$的费用<br>初始$f[U_1]$;结果:$f[U_n]$</p><h3 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h3><p>适用动态规划的问题必须满足最优化原理和无后效性。</p><ol><li><em>最优化原理(最优子结构性质)</em> 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的所有决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。</li><li><em>无后效性</em> :将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</li><li><em>子问题的重叠性</em> : 动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。<em>动态规划实质上是一种以空间换时间的技术</em> ，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。</p><ul><li>线性动规：最长上升子序列，拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等</li><li>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等</li><li>背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶</li><li>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等</li><li>棋盘动规：传纸条，方格取数</li><li>状压动规：玉米田，炮兵阵地</li></ul><h3 id="和其他算法的联系"><a href="#和其他算法的联系" class="headerlink" title="和其他算法的联系"></a>和其他算法的联系</h3><p>当然动态规划不同阶段的决策之间也是相互联系的，即当前目标决策数与先前相同，而当前目标由先前变化过来。而另一种算法贪心则是决策之前不存在联系，进而考虑局部最优。二者之间的区别对比将在今后撰文阐释拙见。</p><h2 id="线性动规"><a href="#线性动规" class="headerlink" title="线性动规"></a>线性动规</h2><h3 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h3><blockquote><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设公司出售一段长度为i英寸的钢条的价格为$Pi$(i = 1, 2, …单位：美元)，下面给出了价格表样例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">长度i</th><th style="text-align:left">价格$Pi$</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">17</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">17</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">30</td></tr></tbody></table></div><p>给定一段长度为n英寸的钢条和一个价格表$P_i$，求切割方案，使得销售收益$R_n$最大。<br>当然，如果长度为n英寸的钢条价格$P_n$足够大，最优解可能就是完全不需要切割。</p></blockquote><p>对于这样一个问题，我们很容易便可以的代入分治的思想，将长度为n的收益用更短钢条的收益进行表示。我们将钢条切割为：$i,n-i$两段，则最优的切割收益则可以用$ R_i+R_{n-i} $进行表示。这样我们就将数据规模大的原问题转换为了数据规模较小的问题，且二者之间很明显仅有数据规模的差别。<br>于是最简单的，我们有这样一个想法：$Rn = max(P_n, R_1 + R_{n-1} , R_2 + R_{n-2} ,…,R_{n-1} + R_1)$<br>进一步简化后就变成了：$R_n=max(R_n,R_{n-1}+P_i)$ ,于是我们便可得到下面的两种方法：</p><h4 id="备忘录法-递归"><a href="#备忘录法-递归" class="headerlink" title="备忘录法(递归)"></a>备忘录法(递归)</h4><p>很多地方都以此为名，事实上就是记录已经计算得到的数值。如果不像这样进行记录的话，将进行大量的重复计算，造成浪费(由此造成的浪费，读者可自行计算，指数级的复杂度)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> p[],<span class="keyword">int</span> n,<span class="keyword">int</span> r[])</span></span>&#123;<span class="comment">//r[]数组即用来记录已经计算出的值的“备忘录”</span></span><br><span class="line">    <span class="keyword">if</span>(r[n]&gt;<span class="number">0</span>)<span class="keyword">return</span> r[n];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            profit=max(profit,[i]+cut(p,n-i,r));</span><br><span class="line">        r[n]=profit;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="自底而上的方法"><a href="#自底而上的方法" class="headerlink" title="自底而上的方法"></a>自底而上的方法</h4><p>这其实是我最最常用，应该也是运用最为广泛的解决动态规划问题的模式。单纯的运用数组进行储存，从小的数据规模开始计算，并记录下所有已经计算出来的值。且当你进行计算下面的值时，利用已经记录的值进行计算。即发现，求解问题时，子问题都已经计算完成。这也正好对应了我们动规所体现的分治思想。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> p[],<span class="keyword">int</span> n,<span class="keyword">int</span> r[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;<span class="comment">//对于动规数组的初始化，如果写在main函数中时，在main中也可以做</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            profit=max(profit,p[j]+r[i-j]);</span><br><span class="line">        r[i]=profit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长上升子序列-LTS"><a href="#最长上升子序列-LTS" class="headerlink" title="最长上升子序列(LTS)"></a>最长上升子序列(LTS)</h3><p>题目内容不多加赘述，总而言之，求一个数列中最长的递增子数列。<br>当我们要求n个数的最长上升子序列，可以求前n-1个数的最长上升子序列，之后与第n个数进行判断。而求前n-1个数的最长上升子序列时，我们通过前n-2个数的状态来进行决策。就这样把原问题转化成子问题，直到序列长度为1时，LTS自然为1.<br>根据题意，我们很容易能够得到如下的状态转移方程：</p><p><center>$d[i]=max(d[i],d[j]+1)$</center><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        d[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;=A[i]&amp;&amp;(d[j]+<span class="number">1</span>)&gt;=d[i])d[i]=d[j]+<span class="number">1</span>;</span><br><span class="line">        len=max(d[i],len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>于是我们根据想法得到了上述的代码。很显然，这样一个$O(n^2)$的算法并不是最优的。在数据范围较大的情况下，这并不合适。其实可以看到，我们在上述流程中，就是从序列中选取元素，存储到另一个存放当前子序列的数组中。而我们也可以模拟一个这样的栈。对于新扫描的数进行决策，若大于栈顶元素，则入栈；若小于等于栈顶元素，则找到比他大的第一个数，并替换(当然这里搜索的内容我们就可以使用二分查找)。最后模拟的栈的大小即为最长子序列的长度。而此时，算法的时间复杂度为$O(nlogn)$。<br>以这样一个数列为例：“2,7,1,5,6,3,8,9,10,4”</p><blockquote><p>取出,2,入栈<br>取出,7&gt;2,入栈<br>取出,1<2,替换,此时栈内数为:1,7 取出,5<7,替换,此时栈内数为:1,5="" 取出,6="">5,入栈,此时栈内数为:1,5,6<br>取出,3<5<6,替换,此时栈内数为:1,3,6 取出,8="">6,入栈,此时栈内数为:1,3,6,8<br>取出,9&gt;8,入栈,此时栈内数为:1,3,6,8,9<br>取出,10&gt;9,入栈,此时栈内数为:1,3,6,8,9,10<br>取出,4&lt;6,替换,此时栈内数为:1,3,4,8,9,10</5<6,替换,此时栈内数为:1,3,6></2,替换,此时栈内数为:1,7></p></blockquote><p>显然这样的一个算法流程得到的序列并不是很正确的最长上升子序列，仅能得出最长子序列的长度。如果要得到正确的序列，还是需要另行记录的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">int</span> i,j,n,s,t,a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">-1000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;a[s]) a[++s]=t;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//二分查找</span></span><br><span class="line">            <span class="keyword">int</span> l=<span class="number">1</span>,r=s,m;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                m=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(t&gt;a[m]) l=m+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[l]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="拦截导弹"><a href="#拦截导弹" class="headerlink" title="拦截导弹"></a>拦截导弹</h3><blockquote><h5 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h5><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。<br>输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 </p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>一行，为导弹依次飞来的高度 </p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数 </p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><p>389 207 155 300 299 170 158 65 </p><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><p>6<br>2</p></blockquote><p>很明显，求最多能够拦截的导弹数是类似于上述最长上升子序列的变式题。不过本题所要求的是最长非上升子序列。于是有如下状态转移方程：<br>$dp[i]=max(dp[i],dp[i-1]+1)&nbsp;&nbsp;(num[i]&lt;=num[j])$&nbsp;<br>而求拦截所有导弹所需要配备的系统数则刚好相反，正是求最长上升子序列。可以想见，每一个最长上升子序列中的数，都引导了一个下降(非上升)的序列，正是我们要拦截的导弹。于是状态转移方程如下：<br>$dp[i]=max(dp[i],dp[i-1]+1)&nbsp;&nbsp;(num[i]&gt;num[j])$&nbsp;<br>于是可以看出二者转移方程只有微小差异，我们用一个流程即可解决问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>],dps[<span class="number">10010</span>];<span class="comment">//下降&amp;上升两个序列分别记录</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>,num[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x)num[++n]=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dp[i]=dps[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]&lt;=num[j])</span><br><span class="line">    dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);<span class="comment">//下降序列</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dps[i]=max(dps[i],dps[j]+<span class="number">1</span>);<span class="comment">//上升序列</span></span><br><span class="line">ans1=max(ans1,dp[i]);</span><br><span class="line">    ans2=max(ans2,dps[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="棋盘动规"><a href="#棋盘动规" class="headerlink" title="棋盘动规"></a>棋盘动规</h2><h3 id="传纸条"><a href="#传纸条" class="headerlink" title="传纸条"></a>传纸条</h3><h3 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h3><h2 id="区域动规-区间动规"><a href="#区域动规-区间动规" class="headerlink" title="区域动规(区间动规)"></a>区域动规(区间动规)</h2><h3 id="石子归并"><a href="#石子归并" class="headerlink" title="石子归并"></a>石子归并</h3><h3 id="统计单词数"><a href="#统计单词数" class="headerlink" title="统计单词数"></a>统计单词数</h3><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><h3 id="02完全背包"><a href="#02完全背包" class="headerlink" title="02完全背包"></a>02完全背包</h3><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><h3 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h3><h2 id="树型动规"><a href="#树型动规" class="headerlink" title="树型动规"></a>树型动规</h2><h3 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h3><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><h3 id="聚会的欢乐"><a href="#聚会的欢乐" class="headerlink" title="聚会的欢乐"></a>聚会的欢乐</h3><h2 id="状压动规"><a href="#状压动规" class="headerlink" title="状压动规"></a>状压动规</h2><h3 id="玉米田"><a href="#玉米田" class="headerlink" title="玉米田"></a>玉米田</h3><h3 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a>炮兵阵地</h3><p><em>未完待续</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;&lt;del&gt;动规对于刚刚涉猎算法的我而言，简直是天书一般啊啊啊!&lt;/del&gt;&lt;br&gt;个人理解上，动态规划通常把问题划分成规模更小的子结构或者子
      
    
    </summary>
    
    
      <category term="动规" scheme="http://Farewellswind.github.io/tags/%E5%8A%A8%E8%A7%84/"/>
    
  </entry>
  
  <entry>
    <title>天舞之序</title>
    <link href="http://Farewellswind.github.io/2018/11/22/%E5%A4%A9%E8%88%9E%E4%B9%8B%E5%BA%8F/"/>
    <id>http://Farewellswind.github.io/2018/11/22/天舞之序/</id>
    <published>2018-11-22T14:38:52.000Z</published>
    <updated>2018-11-22T14:51:32.147Z</updated>
    
    <content type="html"><![CDATA[<p><em><a href="#">步非烟</a> <del>怕是我看过的最早的小说的作者了，文笔着实细腻，高考满分系列</del></em></p><h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><blockquote><p>传说每一个世界<br>最终都会劫灭<br>重入轮回。<br>在那一天<br>一只美丽的雪妖<br>会从雪原深处走出<br>为绝望的世人<br>跳起<br>葬天之舞</p></blockquote><h2 id="诗梦长安"><a href="#诗梦长安" class="headerlink" title="诗梦长安"></a>诗梦长安</h2><p>这个故事曾被我命名为《妖气长安》。<br>因为，我想书写我梦中的盛唐。<br>盛唐是我们所有人心中，一场繁花落尽的梦。<br>她以天山明月为眼睛，以曲江诗酒为风骨，以霓裳羽衣为华裳。<br>长安，却是她的灵魂。<br>每一个民族，都曾有一个记忆。<br>每一个人，都有一个梦想。<br>我们的记忆，我们的梦想，便是长安。<br>长安。<br>长安在哪里？<br>只需沿着梦中那盎然的古意，你便会走到长安。<br>西望瑶池降王母，东来紫气满函关。<br>长安。<br>提马灞桥上，吟鞭挥指，便是长安。三秦城阙，五津风烟，长安便在不远。<br>它曾经是大地上最伟大的都城。<br>千年前，它沐浴东来的紫气，万国来朝。千年后，在我们梦想的彼岸，矗立永远。<br>只要翻开一卷卷诗篇，只要重听一曲曲霓裳羽衣，长安历历风华，便全都涌到了眼前，化作繁锦十丈，红尘万里，乱舞眼前。<br>江头宫殿锁千门的长安，万国衣冠拜冕旒的长安，绣罗衣裳照暮春的长安！<br>这是我们记忆中的辉煌，这是我们梦中的繁华。<br>这繁华，凝聚了一千年的过去，赊欠了一千年的未来。<br>刻骨铭心。<br>往者不可谏，来者犹可追。<br>每个人心中都有自己的长安。<br>对于王侯将相，长安是四夷宾服，是九天宫阙。<br>对于李杜王孟，长安是苍茫明月，是曲江飞花。<br>对于我，长安是盛唐的灵魂，是梦想的都城。<br>曾一直在想，盛唐的长安城中，到底生活着、行走着徜徉着怎样的人？他们身上到底闪耀着怎样的光华？让我们千载之下，如此慨叹。<br>后来我明白了，所谓盛唐气象，最动人的一处，便是因为它不仅仅存在于帝王将相、李杜王孟身上。<br>每一个打马边陲的军人，都沐浴着长河落日的光辉，吞吐着辟土开疆的豪气。<br>每一个行卷长安的书生，都充满了建功立业的渴望，怀揣着致君尧舜的梦想。<br>每一个游吟曲江的诗人，都沾染了刻骨的风华，吟唱着宛如云霞的诗篇。<br>他们或早已埋骨塞外，或一生白首青衫，或至死诗名未传。但他们身上，也已打下了盛唐人物的深深烙印。宛如敦煌那斑驳陆离的长卷，哪怕最不起眼的一笔，也铭刻着千年不褪的色彩。<br>于是，那不再一个人的恢弘盛世。<br>而是一场上天刻意安排的聚会。<br>上天不知花费了多少苦心，让这些浓墨重彩的人，汇聚到这个伟大的时代，伟大的都城。<br>那不是一个人的霓裳羽衣。<br>而是一场繁华的天舞。<br>每一个人，都是舞者。<br>每一个人，都风华绝代。<br>重彩淋漓。</p><h2 id="天舞华音"><a href="#天舞华音" class="headerlink" title="天舞华音"></a>天舞华音</h2><p>很早就曾说过，舞衣霓裳，诗酒明月，这是我眷恋一生的梦。<br>但这个梦太过于沉重，我踟躇多年，都未将之化于文字。<br>我构划了我生命中的第一个世界，《华音》的世界。那时候，我没有直接书写这个梦，而是将那个世界放在了晚明，仅仅让华音阁中，保留了一种对盛唐的固执追忆。<br>那是繁华不再的追忆，那是乱世到来前，对盛世的企慕与追缅。一直以为，华音的美，正在于此。但这种美也注定了格格不入，注定了铺天盖地的悲凉。<br>直到这一刻，我终于直面这个梦境，开启一个新的世界，书写前所未有的瑰丽与奇伟。<br>在这个梦境中的长安，不仅是万国来朝，九族争聚的都城，还是一个神魔仙灵共存的世界。每个人都可以自由的行走，这自由超越了人世间的九州，也超越了三界众生。<br>这场天舞的舞者，不仅仅是人。无论仙、灵、妖、魔，只要来到这个世界，便能平等的分享这场繁华。用它们刻骨的爱与恨，将这场天舞装点得更加灿烂。<br>这场天舞的舞台，从长安蔓延。它将横跨大漠、雪原、神山、九幽。每一寸土地，都将用它瑰奇苍茫的风物，将这场天舞烘托得更加宏伟。<br>我将穷极想象，展开这万里舞台，再无犹疑，再无保留。<br>让那一轮盛唐明月，照花长安，照酒曲江，照亮了大明宫的龙池凤阙，照亮了春江两岸相思楼台，也照亮了玉门之外云海关山。<br>让那一场盛世天舞，舞落烟花，舞乱羽衣，舞罢了响彻梨园的丝竹笙歌，舞起了连绵数年的渔阳鼙鼓，也舞破了开天盛世那段滔天繁华。<br>明月照耀，天舞长安。<br>芸芸众生，天地万物，都是舞者，在这轮长安的明月下尽情绽放。<br>直到，舞破中原。<br>这是一场葬天之舞。</p><h2 id="历史诗篇"><a href="#历史诗篇" class="headerlink" title="历史诗篇"></a>历史诗篇</h2><p>这不是真实的盛唐，是一个人神共存，飞仙往来、神奇诡谲的梦境。<br>仙仗出于崆峒，王母降于瑶池。<br>这不是历史，而是传说，是诗篇。<br>这个故事里每一处土地，都有神魔仙灵在自由徜徉，分享着这个浮世鼎盛的荣耀。<br>这个故事里的每一个人物，都会对应一位大唐的诗人，传承着他们灿烂的风华。<br>仅仅是美学上的相似，而不是履历、性格或者外貌上的暗合。<br>李白的恣肆，杜甫的沉郁，李贺的诡谲，义山的隐幽，都将在他们身上寻到点滴踪迹。<br>或许，每一个民族，都会人站出来，为他们共同的记忆书写历史。<br>我，不想书写历史。<br>我只想为深爱着这场梦中天舞的人。<br>拾起那一卷舞落的烟华。<br><em>天舞霓裳，诗梦长安。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;&lt;a href=&quot;#&quot;&gt;步非烟&lt;/a&gt; &lt;del&gt;怕是我看过的最早的小说的作者了，文笔着实细腻，高考满分系列&lt;/del&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;
      
    
    </summary>
    
    
      <category term="摘录" scheme="http://Farewellswind.github.io/tags/%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>迷恋与背叛——[霸王别姬]</title>
    <link href="http://Farewellswind.github.io/2018/11/22/%E8%BF%B7%E6%81%8B%E4%B8%8E%E8%83%8C%E5%8F%9B%E2%80%94%E2%80%94-%E9%9C%B8%E7%8E%8B%E5%88%AB%E5%A7%AC/"/>
    <id>http://Farewellswind.github.io/2018/11/22/迷恋与背叛——-霸王别姬/</id>
    <published>2018-11-22T08:40:00.000Z</published>
    <updated>2018-11-22T13:50:47.067Z</updated>
    
    <content type="html"><![CDATA[<p>必须承认，在看这部电影之前，对国产电影有种本能的偏见，认为就是拍不过人家的大导演，拍不出人家的大手笔。当然，其实这是谬论。现在不用谁站出来批判一下我的这种情节，我自己也会毫不客气的承认。 </p><p>从前对张国荣一直都没有感觉，可在[霸王别姬]里，每每看到他，都会有心灵为之一颤的感觉。那种没落贵族的高雅气质，那种哀怨而骄傲的眼神，那种轻柔又充满感情的动作，无一不让人心牵程蝶衣的所有一切。他的情感，他的心情，他爱的人与他妒忌的人。 </p><p>其实蝶衣是个单纯的人。被师傅逼着从小唱坤角。但每次都会说“<em>我本是男儿郎，又不是女娇娥</em>”。他是为了小石头，为了那个一直照顾他、关爱他的大师哥、后来的霸王段小楼而留了下来，心甘情愿的在后来唱：<em>我本是女娇娥，又不是男儿郎</em>。 </p><p>他并不知道，在那以后，他所有的心情与情感就轻轻的在这句话里被颠覆了。 </p><p>从此，小豆子成为了程蝶衣；或者，更确切地说，只是成为 “虞姬”，虽然他也演“贵妃醉酒”，扮“牡丹亭”，但他的心愿，只是与他的霸王呆在一起唱一辈子的戏，做到师傅昔日里说的那般，“<em>从一而终</em>”。但就如段小楼所说，他忘记了，戏与人生本是两码事，他偏要将戏中全部的思想与情感倾倒进生活，如此固守，执迷不悔。 </p><p>直到菊仙的出现，直到这个名妓抢去了他的“霸王”。不知道为什么，在看到所有人恭贺着段小楼能与菊仙定亲而程蝶衣突然打开房门安静的出现在热闹的人群中时，心里会生出深深的遗憾与伤感。我想我是被蝶衣单纯的执著所感动，以至于始终对处在这场纠葛中的最大受伤者抱有同情与遗憾。</p><p>除了段小楼，京剧就该是他最难割舍的东西了。其实人戏不分倒也正能从另一个侧面反映出他对戏的痴迷。他为日本人唱戏，开始仅仅是为了营救段小楼，但青木对京剧的尊重与喜爱又令他不自禁的感到宽慰。相较之下，段小楼、小四所代表的所谓“<em>劳动人民</em>”反显出一种可笑的愚昧。</p><p>相对于蝶衣，菊仙要幸运得多，也不幸得多。她得到了段小楼的爱，却也经受了他的背信弃义。对于蝶衣，她内心始终复杂：既反感他人戏不分地迷恋自己的丈夫，又轻视他耍尽手腕要与段小楼在一起。作为女人，她在身为名妓时就渴望从良，有种要保护自己家庭的本能。她认为一切的不祥都缘于蝶衣，所以曾强烈要求丈夫与他分开；但她胆色过人，同样心地宽厚，心疼被毒瘾折磨得死去活来的蝶衣，怜惜无法上台演绎“虞姬”的蝶衣，甚至在丈夫揭发蝶衣时也予以喝止。在她生命的尽头时刻，只是澹然的将蝶衣送给小楼的剑放还给揭发了她的蝶衣，然后转身，回头，轻轻一笑，无奈伤感却无限宽容。这个八面玲珑的女子被自己深爱并深信的丈夫推向深渊，却没有再去害任何人。坚强，孤独，又那么骄傲。</p><p>可笑的是被他们两个同时迷恋的“霸王”。迷恋是什么？那是包含了太多纯粹与伤感的东西。挚爱，信任，无悔，崇拜，是一种深陷其中欲罢不能也不愿的盲目情感。但整个悲剧的最深邃最惨烈之处，正在于这种迷恋所遭受的彻底的毁灭性打击。两个人共同的偶像在自身难保的情况下几乎没有犹豫就作出了决断——背叛。而对象就是他深爱的妻与深信的师弟。</p><p>直到最后。历经种种磨难后的蝶衣与段小楼重新站在了舞台上。二人再度合作起那场见证了他们全部甜酸苦辣全部心情故事的“霸王别姬”。当段小楼忽然的唱出“<em>我本是男儿郎</em>”时，蝶衣那么自然的接口：又不是女娇娥。段小楼只是说，错了，又错了。蝶衣于是在那刻恍然的醒悟：一直沉溺在戏中多年的情感原来只是“<em>错了，又错了</em>”。他终于没有选择，坦然地拔剑，在那把见证了他们师兄弟从头至尾全部故事的剑下倒地。那样平静，波澜不惊。最终，他在清醒里背叛了自己的情感；也或者，他已经做到了“<em>从一而终</em>”。只因，他是以“小豆子”的身份出现在师兄面前，也以恢复了的“小豆子”的身份死在师兄的脚边。</p><p><strong><em><div class="note primary"><p>两个固守于爱、固守于信仰的人，一个以死保住了自己的清白，一个以死回复了最初的自己，只剩下那个曾经叱咤江湖的“霸王”站在那里。一个人在舞台中央。那么寂寞。</p></div></em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;必须承认，在看这部电影之前，对国产电影有种本能的偏见，认为就是拍不过人家的大导演，拍不出人家的大手笔。当然，其实这是谬论。现在不用谁站出来批判一下我的这种情节，我自己也会毫不客气的承认。 &lt;/p&gt;
&lt;p&gt;从前对张国荣一直都没有感觉，可在[霸王别姬]里，每每看到他，都会有心灵
      
    
    </summary>
    
    
      <category term="影评" scheme="http://Farewellswind.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>To the Moon</title>
    <link href="http://Farewellswind.github.io/2018/11/22/To%20the%20Moon/"/>
    <id>http://Farewellswind.github.io/2018/11/22/To the Moon/</id>
    <published>2018-11-22T07:25:54.000Z</published>
    <updated>2018-11-22T13:50:52.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一个游戏，一个好故事，一段纯粹的爱情。</strong></p><p>就像作小学课文的思考题一样，游戏、应该说这个故事是让人带着为什么要去月球的问题进行的，随着逆行老人的生命时光，追本溯源，才渐渐明白整个故事的始末，去月球，是两人爱情的本质。</p><p>在整个故事攻略过程中我发现我喜欢上了River这样的女孩子，这样一个奇怪的女孩子。我还记得电影院那一段，John以为自己被放了鸽子一个人郁闷地看了电影，出来后才发现River在另一边看了电影。John纠结于为什么不一起进场、坐在一起，River则表示并没有什么区别。然而这样的奇怪是River自小就伴随的孤独症，使常人无法理解她的言行心思，也使她的行为与常人相异。或许她在电影开始前没有与John搭话，过程中也没有坐在一起，是因为在River眼中只有John一人，搭不搭话坐不坐在一起她意识不到，她只知道她和John在一起，使得她同样无法理解John纠结。</p><p>John也是奇怪，有着自己不喜的爱好。俩个人的奇怪，John的失忆与River的孤独症是整个故事最大的矛盾冲突。</p><p>这个故事打动我的是戏剧冲突下的纯粹的爱情，故事中John与River有三次相遇，从时间上发展上说，第一次John离开狂欢节热闹的人群，发现了看星空的River。星空下相聊，星空下相约。</p><p>这一次两小无猜。</p><p>对River来说一个人在看星空是孤独症的困扰，出神之际，John却是简简单单地走入了内心，所以说女生的情商发育早，而且是孤独症的River，只是一次聊天，一个约定，就在心里埋下了种子，这一次对River来说是情窦初开。</p><p>John并没有遵守约定，他失忆了。即使故事没有描述，我们也能知道River在此后的时光里，一个人在星空下等待。直到有一天，他们在学校相遇。或许是River这样安静的女孩子正是John的菜，或许是潜意识的指引，John在哥们的怂恿下跑去向坐在角落里看书的River告白。River一眼就出John当年星空下一起约定的另一半，我更觉得是River早就发现了John，一直等到John来自己身边，伴随孤独症的她就是这样的性格，即使不说话，我们却是在一起。所以无需多说什么就答应了John，惊呆了John和他的小伙伴。</p><p><strong>这一次执子之手，与子偕老。</strong></p><p>是的，这一次相遇之后，两人的关系并无波澜，相恋，结婚，直到老去。唯一有问题的是，John没有想起小时候的事，所以我的纠结病来了，River喜欢的是当年那个John，失忆的他还是他么？River给了我答案，她并无提及当年的事情，通过折兔子，看灯塔……让常人无法理解的方式暗示John，始终无果，却不说破。即使带着遗憾死去，也不后悔。</p><p>就像在婚礼上John对River爱情问题的回答一样，爱~责任。他只是一个失忆的普通人，面对深受孤独症折磨的River，即使无法理解也不离不弃，爱她就带她远离尘世，在山顶上在灯塔旁在靠近星星的地方盖了房子。随着症状的加深River的行为越来越奇怪，反复询问同样的问题，John回答了每一次同样的回答，还创作了到现在我听了都会心起涟漪的致River。</p><p>River先一步离开人间，John随后也即将走到生命的尽头，却是留有了去月球的念头。搜寻记忆用时太长，转眼John就要死亡。可john也不明白去月球的理由，主角组为了在John死前完成任务进行了一场豪赌，在John记忆中的人生中移除了River，没有了照顾River的责任，这一次的人生中John在自己也不明白的情况下顺风顺水地当上了宇航员。在登月的时候，第三次与移除了的River相遇，抛去主角组的设计可能，John潜意识驱使的可能，River的灵魂在这一刻显现的可能……</p><p>这一次我想称它为奇迹。</p><p>第三次相遇，就像CLANNAD小镇的光一样，是他们引发的奇迹，这正是River不说破的答案，源于一开始的约定。</p><p><img align="center" src="http://img0.ph.126.net/mA--B0eXGMAMFxotYSZFLA==/6632731326793866153.png" data-rawwidth="600" data-rawheight="336" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic1.zhimg.com/dc95b8e710e71d7fb9eca55342b8377c_r.jpg"></p><blockquote><p>看那儿。<br>知道吗？天上有无数盏灯<br>嗯。<br>你刚才说这是你的位置吧？<br>我只在狂欢节才来。<br>你不喜欢人多的地方吗？<br>我也不喜欢。<br>……………………<br>就像天上的星星，从这里看过去它们都差不多，但这并不会减少它们的美丽。<br>我也这么觉得。<br>那么你认为这些星星是什么呢？<br>我从未告诉任何人，但我一直认为它们是灯塔。成千上万的灯塔……闪耀着屹立在世界尽头。<br>哇，那上面一定充满活力，热闹喧哗。<br>不是这样的，它们看得到彼此，想交流聊天。<br>可他们无能为力。他们天各一方，无法听清对方的呼唤。<br>它们能做的……唯有努力地绽放光芒。让那光芒照耀着其他灯塔，也照耀着我。<br>为什么是你？<br>因为总有一天……我也会成为他们的朋友。<br>你明年还会来吗？<br>会的。<br>老时间？老地点？<br>嗯。<br><strong><em>如果你忘记了，或是走丢了呢？<br>那么我们总会在月亮上相遇的。</em></strong></p></blockquote><p>正是这个约定，River不必揭露John之前的记忆，John不必理解River奇怪的所做所为，我眼中纠结的遗憾的问题变得无所谓。找回当年的John重要么？孤独症缠身的River与只是常人的John互相理解透彻重要么？这一切只是John一场梦重要么？</p><p>River真是傻可以，为一个只是刚见面的人，为一个不是海誓山盟的约定，恪守一生。用折兔子什么的来表达自己小女孩的心思，她身患孤独症，她并不喧闹充满活力，她只能用自己的方式照耀John，努力绽放光芒，像童话般的公主一样，守护着童话般的约定。</p><p>John也是傻可以，即使自己不明白，不懂River，却像童话般的王子一样，抱起她，带她私奔，带她离开世人的异样眼光，为她盖起城堡。爱与责任，守护着被孤独症诅咒的River。</p><p>啊啊啊，就是这样的纯粹，没有乱七八糟的东西，简简单单的相遇，相恋，相爱。可是就是丫的打动了我。</p><p>在故事的最后John <strong>忘记了</strong>，River <strong>走丢了</strong>，这都无所谓，因为说好了，<strong>他们定会在月亮上相遇</strong></p><p>这只是John的一场梦也罢，不重要，他们生前或是说一开始就知道两个人纯粹的爱情本质，<br><strong><em>to moon，去月球</em></strong>。</p><p><img align="center" src="http://img0.ph.126.net/BlJlBKMR7wbvXfiJJ_BE4w==/1674494636552351808.jpg" data-rawwidth="508" data-rawheight="968" class="origin_image zh-lightbox-thumb" width="508" data-original="https://pic1.zhimg.com/e3a6a63812f4d69c877cfdb0b73590ec_r.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一个游戏，一个好故事，一段纯粹的爱情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像作小学课文的思考题一样，游戏、应该说这个故事是让人带着为什么要去月球的问题进行的，随着逆行老人的生命时光，追本溯源，才渐渐明白整个故事的始末，去月球，是两人爱情的本质。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="游评" scheme="http://Farewellswind.github.io/tags/%E6%B8%B8%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Summary</title>
    <link href="http://Farewellswind.github.io/2018/11/20/Summary/"/>
    <id>http://Farewellswind.github.io/2018/11/20/Summary/</id>
    <published>2018-11-20T09:54:41.000Z</published>
    <updated>2018-11-22T13:51:08.506Z</updated>
    
    <content type="html"><![CDATA[<p><em>不知不觉，成为一个大学僧已经小半年了。</em><br><em>但是扪心自问，我似乎又什么都没有做。</em><br><em>半年的茫然，无所适从。</em><br><em>++待续</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;不知不觉，成为一个大学僧已经小半年了。&lt;/em&gt;&lt;br&gt;&lt;em&gt;但是扪心自问，我似乎又什么都没有做。&lt;/em&gt;&lt;br&gt;&lt;em&gt;半年的茫然，无所适从。&lt;/em&gt;&lt;br&gt;&lt;em&gt;++待续&lt;/em&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活记录" scheme="http://Farewellswind.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="方向 废话" scheme="http://Farewellswind.github.io/tags/%E6%96%B9%E5%90%91-%E5%BA%9F%E8%AF%9D/"/>
    
  </entry>
  
</feed>
